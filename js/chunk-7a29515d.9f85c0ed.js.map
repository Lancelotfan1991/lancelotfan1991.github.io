{"version":3,"sources":["webpack:///./src/markdown/AboutReact sync nonrecursive \\.md$","webpack:///./src/markdown/AboutRegExp/5-分组捕获和分组引用.md","webpack:///./src/markdown/AboutJS/JS基础-事件循环EventLoop.md","webpack:///./src/markdown/AboutRegExp/1-正则简单介绍.md","webpack:///./src/markdown/AboutRegExp/2-常用的正则表达式.md","webpack:///./src/markdown/AboutJS sync nonrecursive \\.md$","webpack:///./src/markdown/AboutLaya sync nonrecursive \\.md$","webpack:///./src/markdown/AboutDataStructure sync nonrecursive \\.md$","webpack:///./src/markdown/AboutJS/JS基础-原型链.md","webpack:///./src/markdown/AboutJS/JS基础-闭包.md","webpack:///./src/markdown/AboutWebpack sync nonrecursive \\.md$","webpack:///./src/markdown/AboutAlgorithm sync nonrecursive \\.md$","webpack:///./src/markdown/AboutRegExp/3-Replace方法与正则.md","webpack:///./src/markdown/AboutRegExp/4-正则的捕获.md","webpack:///./src/markdown/AboutRegExp sync nonrecursive \\.md$","webpack:///./src/markdown/AboutRegExp/6-正则捕获的贪婪性.md","webpack:///./src/markdown/AboutVue sync nonrecursive \\.md$","webpack:///./src/views/Articles/data/ArticleData.js","webpack:///./src/markdown/AboutWebpack/06Webpack.md","webpack:///./src/markdown/AboutVue/Vue响应式源码.md"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","map","webpackContext","webpackContextResolve","__webpack_require__","o","Object","ArticleData","type","title","articleNames","require","articleContent"],"mappings":"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","file":"js/chunk-7a29515d.9f85c0ed.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"0a8d\";","// Module\nvar code = \"<h3 id=分组捕获和分组引用>分组捕获和分组引用</h3> <p>分组的第三个作用：“分组引用”</p> <pre><code class=language-javascript>let str=&quot;book&quot;\\nlet reg=/^[a-zA-Z]([a-zA-Z])\\\\1[a-zA-Z]$/\\n\\n//分组引用就是通过“\\\\数字”让其代表和对应分组出现一摸一样的内容\\n\\nconsole.log(reg.test(&#39;foot&#39;));//=&gt;true\\nconsole.log(reg.test(&#39;book&#39;));//=&gt;true\\nconsole.log(reg.test(&#39;fan&#39;));//=&gt;false</code></pre> \";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h2 id=js基础-事件循环eventloop>JS基础-事件循环EventLoop</h2> <p>来自转载：</p> <p>宏队列和微队列 宏队列，macrotask，也叫tasks。 一些异步任务的回调会依次进入macro task queue，等待后续被调用，这些异步任务包括：</p> <p>setTimeout setInterval setImmediate (Node独有) requestAnimationFrame (浏览器独有) I/O UI rendering (浏览器独有) 微队列，microtask，也叫jobs。 另一些异步任务的回调会依次进入micro task queue，等待后续被调用，这些异步任务包括：</p> <p>process.nextTick (Node独有) Promise Object.observe MutationObserver （注：这里只针对浏览器和NodeJS）</p> <p>1，执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）； 全局Script代码执行完毕后，调用栈Stack会清空； 2，从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1； 3，继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行； 4，microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空； 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行； 5，执行完毕后，调用栈Stack为空； 6，重复第3-7个步骤； 7，重复第3-7个步骤； ......</p> <pre><code class=language-javascript>console.log(1);\\n\\nsetTimeout(() =&gt; {\\n  console.log(2);\\n  Promise.resolve().then(() =&gt; {\\n    console.log(3)\\n  });\\n});\\n\\nnew Promise((resolve, reject) =&gt; {\\n  console.log(4)\\n  resolve(5)\\n}).then((data) =&gt; {\\n  console.log(data);\\n})\\n\\nsetTimeout(() =&gt; {\\n  console.log(6);\\n})\\n\\nconsole.log(7);</code></pre> <p>作者：liuxuan 链接：<a href=https://segmentfault.com/a/1190000016278115>https://segmentfault.com/a/1190000016278115</a> 来源：SegmentFault 思否 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p> \";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h2 id=正则表达式regular-expression>正则表达式Regular Expression</h2> <p>RegExp：用来处理字符串的规则</p> <ul> <li>只能处理字符串</li> <li>他是一个规则，可以验证字符串是否符合某个规则test</li> <li>也可以把符合规则的内容捕获到exec /match</li> </ul> <pre><code class=language-javascript>let str=&quot;good good study,day day up!&quot;\\nlet reg=/\\\\d+/;//\\\\d代表0-9之间的一个数字，+代表出现一到多次\\n\\nreg.test(str);//判断字符串里是否有数字 //=&gt;false\\n\\nstr=&quot;2019-08-12&quot;;\\nreg.exec(str);//捕获str中符合条件的部分\\n</code></pre> <p>编写正则表达式：</p> <p>创建方式有两种：</p> <pre><code class=language-javascript>//字面量创建方式(两个斜杠之间包起来的，都是用来描述规则的元字符)\\nlet reg1=/\\\\d+/\\n\\n//构造函数方式调用 两个参数(元字符字符串，修饰符字符串)\\nlet reg2=new RegExp(&quot;\\\\\\\\d+&quot;);\\n**需要转义</code></pre> <h3 id=正则表达式由两部分构成>正则表达式由两部分构成</h3> <ul> <li>元字符</li> <li>修饰符</li> </ul> <h3 id=常见的元字符>常见的元字符</h3> <pre><code>//1，量词元字符：设置出现的次数\\n//*            =&gt;0到多次\\n//+            =&gt;1到多次\\n//?            =&gt;0或1次\\n//{n}        =&gt;出现n次\\n//{n,}        =&gt;出现n到多次\\n//{n,m}        =&gt;出现n到m次\\n\\n//2，特殊元字符：单个或者组合在一起代表特殊的含义\\n// \\\\        =&gt;转义字符(普通-&gt;特殊-&gt;普通)\\n// .        =&gt;除了\\\\n以外的任意字符\\n// ^        =&gt;以哪一个元字符作为开始\\n// $        =&gt;以哪一个元字符作为结束\\n// \\\\n        =&gt;换行符\\n// \\\\d        =&gt;0-9之间的一个数字\\n// \\\\D        =&gt;非0~9之间的任何一个数字\\n// \\\\w        =&gt;数字，字母，下划线中的任意一个字符\\n// \\\\s        =&gt;一个空白字符\\n// \\\\t        =&gt;一个制表符（一个tab键，四个空格）\\n// x|y        =&gt;x或者y中的一个字符  \\n// 1|5|9    =&gt;1或者5或者9中的一个字符\\n// [xyz]    =&gt;xyz中的任何一个字符\\n// [^xyz]    =&gt;非xyz的字符\\n// [a-z]    =&gt;指定a-z这个范围中的任意字符\\n// [0-9a-zA-Z_]    =&gt;0-9,a-z,A-Z,下划线\\n// \\\\b        =&gt;匹配一个单词的边界\\n// ()        =&gt;分组\\n// (?:)        =&gt;只匹配不捕获\\n// (?=)        =&gt;正向预查\\n// (?!)        =&gt;负向预查\\n\\n//3,普通元字符：代表本身含义\\n/zhufeng/    此正则匹配的就是“zhufeng”</code></pre><h3 id=常见的修饰符img>常见的修饰符img</h3> <pre><code class=language-javascript>i ignorecase        忽略单词大小写匹配\\nm multiline            忽略换行匹配\\ng global            全局匹配\\n\\n/A/.test(&#39;fan&#39;);    false,大小写不匹配\\n/A/i.test(&#39;fan&#39;);    true,忽略大小写匹配</code></pre> <h3 id=xy><code>x|y</code></h3> <pre><code>reg=/^(18|29)$/\\n/^(18|29)$/\\nreg.test(&#39;18&#39;)\\ntrue\\nreg.test(&#39;29&#39;)\\ntrue</code></pre><h3 id=\\\"\\\"><code>[]</code></h3> <p>中括号中的字符一般都代表本身的含义</p> <pre><code>reg=/^[@+]+$/        //代表匹配@或者+出现1到多次，并且以@+开头结尾的字符\\n/^[@+]+$/\\nreg.test(&#39;@@@&#39;)\\ntrue\\nreg.test(&#39;+++&#39;);\\ntrue\\nreg.test(&#39;@+&#39;);\\ntrue\\nreg.test(&#39;123123123&#39;);\\nfalse\\nreg.test(&#39;12@+123&#39;);\\nfalse\\nreg.test(&#39;@++++&#39;);\\ntrue\\n\\n//中括号中的\\\\d代表0-9的任意字符\\nreg=/^[\\\\d]$/\\n/^[\\\\d]$/\\nreg.test(&#39;9&#39;);\\ntrue\\nreg.test(&#39;d&#39;);\\nfalse\\nreg.test(&#39;\\\\&#39;)\\nVM1442:1 Uncaught SyntaxError: Invalid or unexpected token\\nreg.test()\\nfalse\\nreg.test(&#39;\\\\\\\\&#39;);\\nfalse\\n\\n//中括号中不存在多位数\\nreg=/^[18]$/\\n/^[18]$/\\nreg.test(&#39;18&#39;);\\nfalse\\nreg.test(&#39;1&#39;)\\ntrue\\nreg.test(&#39;8&#39;)\\ntrue</code></pre>\";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h3 id=常用的正则表达式>常用的正则表达式</h3> <h4 id=1，验证是否是有效数字>1，验证是否是有效数字</h4> <pre><code class=language-javascript>/*\\n *规则分析：\\n *1.可能出现+,-也可能不出现  ^[+-]?\\n *2.一位0-9都可以，多位首位不能为0    (\\\\d|([1-9]\\\\d+)) 要不然就是0-9，要不然就是1-9开头，然后重复多次0-9。\\n *3.小数部分，可能有，可能没有，一旦有，后面必须有小数点加数字 （\\\\.\\\\d+）? 以小数点.开头，一段数字结尾，并重复0到1次\\n */\\n\\nreg=/^[+-]?(\\\\d|([1-9]\\\\d+))(\\\\.\\\\d+)?$/\\n</code></pre> <h4 id=2，验证密码>2，验证密码</h4> <pre><code class=language-javascript>1，数字字母下划线\\n2，6-15位\\n\\nlet value=input.value;\\nlet reg=/^\\\\w{6-16}$/\\nlet flag=reg.test(value);\\nflag==true &amp;&amp; alert(&#39;符合密码规则&#39;);\\nflag==false &amp;&amp; alert(&#39;不符合密码规则&#39;);</code></pre> <h4 id=3，验证真实姓名>3，验证真实姓名</h4> <pre><code class=language-javascript>//1，尼古拉斯·赵四\\n//2，汉字的正则 \\nlet reg=/^[\\\\u4E00-\\\\U9FA5]$/\\n//3，长度2-10位\\n//4，可能有译名    ·汉字\\nlet reg=/^[\\\\u4E00]-\\\\U9FA5]{2-10}(·[\\\\u4E00-\\\\u9FA5]{2,10}){0,2}$/\\n</code></pre> <h4 id=4，验证邮箱>4，验证邮箱</h4> <pre><code class=language-javascript>let reg=/^\\\\w+ ((-\\\\w+)|(\\\\.\\\\w+))* @[A-Za-z0-9]+ ((\\\\.|-)[A-Za-z0-9]+)* \\\\.[A-Za-z0-9]+$/\\n\\n//开头是数字字母下划线\\n//@符之前是数字字母下划线和.组成0到多次\\n//@\\n//@符之后是数字字母出现一到多位\\n//之后是-或者. 跟着数字字母 0到多次\\n//最后是.com .cn .org .net .edu这种，由点开始出现一到多次\\n\\n举例：\\nlancelotfan@163.com.cn\\nzxt@zhufeng-peixun-office.com\\n</code></pre> <h4 id=5，身份证号码>5，身份证号码</h4> <pre><code>//规则分析\\n//长度18位\\n//最后一位可能是X\\n由这两个规则导出的正则：\\nlet reg=/^\\\\d{17}(\\\\d|X)$/\\n\\n//身份证前六位：省市县 34 26 22\\n//中间八位：出生年月日\\n//最后四位： 最后一位：X|数字\\n           倒数第二位：偶数女，奇数男\\n           其余的是前面的14位，经过算法算出来的\\n\\n//小括号第二个作用，分组捕获，不仅可以把大正则匹配的信息捕获到，还能捕获到每个小分组的内容\\nlet reg=/^(\\\\d{6})(\\\\d{4})(\\\\d{2})(\\\\d{2})\\\\d{2}(\\\\d)(\\\\d|X)$/\\nreg.exec(&#39;342622199107172956&#39;)\\n输出结果\\n[&quot;342622199107172956&quot;, &quot;342622&quot;, &quot;1991&quot;, &quot;07&quot;, &quot;17&quot;, &quot;5&quot;, &quot;6&quot;, index: 0, input: &quot;342622199107172956&quot;, groups: undefined]\\n</code></pre>\";\n// Exports\nmodule.exports = code;","var map = {\n\t\"./JS基础-事件循环EventLoop.md\": \"198e\",\n\t\"./JS基础-原型链.md\": \"8582\",\n\t\"./JS基础-闭包.md\": \"9c99\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"407d\";","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"6851\";","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"7c3f\";","// Module\nvar code = \"<h1 id=js基础-原型链>JS基础-原型链</h1> <p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 <code>prototype</code> 属性了。对于 ECMAScript 中的引用类型而言，<code>prototype</code> 是保存着它们所有实例方法的真正所在。换句话所说，诸如 <code>toString()</code>和 <code>valuseOf()</code> 等方法实际上都保存在 <code>prototype</code> 名下，只不过是通过各自对象的实例访问罢了。</p> <p>通过protoType，使得我们创建的对象可以访问原型链上定义的其他属性和方法。比如以下代码：</p> <pre><code class=language-javascript>var a=new Array(3);\\nconsole.log()\\nconsole.log(a);\\nconsole.log(a.__proto__)\\na.toString();\\na.hasOwnProperty();\\na.calculate();\\nObject.prototype.calculate=function(){console.log(&#39;123&#39;)};</code></pre> <p>在上面这个例子中，定义了一个新的数组对象。</p> <p>1)首先尝试打印这个对象，发现这个对象仅仅包含一个length属性以及一个隐藏的proto属性。</p> <p>通过这个proto对象，我们可以允许a调用不存在于自身的方法。</p> <p>2)当我们调用a.toString()方法时，会先判断自身是否有这个方法，如果没有，则沿着原型链一层层往上找。</p> <p>在这个案例中，首先会找到Array.prototype，Array的prototype中定义了数组的多个方法，如pop，reduce，filter等等，从而允许我们对数组进行操作。</p> <p>3)当我们调用hasOwnProperty方法时，会先找到Array.prototype，发现并没有这个方法后，会继续沿着Array.prototype.proto继续寻找，找到Object.prototype里定义的方法。结果输出为false。</p> <p>4)当我们继续调用calculate方法，这个时候会抛出错误，因为并没有从原型链上找到这个方法。</p> <p>5)我们可以给Object的prototype对象添加一个新的方法，名为calculate。</p> <p>6)当我们再次尝试调用a.calculate()，这时将不再报错，因为原型链上已经定义了该方法。</p> <h3 id=prototype的经典使用：>prototype的经典使用：</h3> <p>1，在vue中，由于数组元素的特殊性，vue没有选择监听数组元素下标的变化。而是采取了劫持数组的七个方法的形式。</p> <p>劫持的七个方法分别使：push，pop，shift，unshift，splice，sort，reverse。</p> <p>这七个方法的共同点都是都是对原数组进行了修改。</p> <p>具体的实现是，当我们检测到某个数组需要进行响应式的处理，那么我们会将这个数组的proto指向一个被劫持后的新的对象上去，这个对象里包含了数组的全部方法，只不过对其中的七个方法进行了特殊的处理。当我们对这个数组使用这七个方法时，会使用这新的七个方法。这七个方法里，通过object.defineProperty修改了value属性。</p> <p>当调用时，会通知数组的依赖notify。</p> \";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h1 id=js基础-闭包>JS基础-闭包</h1> <p>每当 JavaScript 执行一个函数时，都会创建一个作用域对象（scope object），用来保存在这个函数中创建的局部变量。它使用一切被传入函数的变量进行初始化（初始化后，它包含一切被传入函数的变量）。这与那些保存的所有全局变量和函数的全局对象（global object）相类似，但仍有一些很重要的区别：第一，每次函数被执行的时候，就会创建一个新的，特定的作用域对象；第二，与全局对象（如浏览器的 <code>window</code> 对象）不同的是，你不能从 JavaScript 代码中直接访问作用域对象，也没有 可以遍历当前作用域对象中的属性 的方法。 </p> <p>作用域对象组成了一个名为作用域链（scope chain）的（调用）链。它和 JavaScript 的对象系统使用的原型（prototype）链相类似。</p> <p>一个<strong>闭包</strong>，就是 一个函数 与其 被创建时所带有的作用域对象 的组合。闭包允许你保存状态——所以，它们可以用来代替对象。</p> <p>案例1：添加计时器</p> <pre><code class=language-javascript>function addCount() {\\n  var conut = 0;\\n  return function() {\\n    count = count + 1;\\n    console.log(count);\\n  };\\n}\\n\\nvar fun1 = addCount();\\nfun1(); //1\\nfun1(); //2\\nvar fun2 = addCount();\\nfun2(); //1\\nfun2(); //2\\n</code></pre> <p>案例2：给一系列元素添加点击事件</p> <pre><code class=language-javascript>var op = document.querySelectorAll(&quot;p&quot;);\\nfor (var j = 0; j &lt; op.length; j++) {\\n  op[j].onclick = function() {\\n    alert(j);\\n  };\\n}\\n//alert出来的值是一样的\\n// 解决办法一:\\nfor (var j = 0; j &lt; op.length; j++) {\\n  (function(j) {\\n    op[j].onclick = function() {\\n      alert(j);\\n    };\\n  })(j);\\n}\\n// 解决办法二:\\nfor (var j = 0; j &lt; op.length; j++) {\\n  op[j].onclick = (function(j) {\\n    return function() {\\n      alert(j);\\n    };\\n  })(j);\\n}\\n//解决方案三\\nfor (let j = 0; j &lt; op.length; j++) {\\n  op[j].onclick = function(){\\n      alert(j);\\n  };\\n}</code></pre> <p>案例3：一个复杂的闭包实践</p> <pre><code class=language-javascript>function fun(n,o) {\\n  console.log(o)\\n  return {\\n    fun:function(m){\\n      return fun(m,n);\\n    }\\n  };\\n}\\nvar a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?\\nvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?\\nvar c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?\\n//问:三行a,b,c的输出分别是什么？\\n//从第一行开始分析：\\nfunc(0)=&gt;undefined,此时o=undefined，n=0,a.fun(1)=0,a.fun(2)=0,fun(3)=0\\n//第二行\\nundefined,0,1,2\\n//第三行\\nundefined,0,1,1</code></pre> <p>闭包的缺陷：</p> <p>会导致内存占用过高，因为变量没有得到释放。</p> \";\n// Exports\nmodule.exports = code;","var map = {\n\t\"./06Webpack.md\": \"f276\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"9d2a\";","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"9e7c\";","// Module\nvar code = \"<h2 id=replace方法与正则>Replace方法与正则</h2> <h4 id=1，replace字符串中实现替换的方法（一般都是伴随正则一起使用的）>1，replace字符串中实现替换的方法（一般都是伴随正则一起使用的）</h4> <pre><code class=language-javascript>let str=&quot;zhufeng@2019|zhufeng@2020&quot;\\n//把&quot;zhufeng&quot;替换成汉字&quot;珠峰&quot;\\n\\n//不使用正则\\nstr=str.replace(&quot;zhufeng&quot;,&quot;珠峰&quot;);\\nstr=str.replace(&quot;zhufeng&quot;,&quot;珠峰&quot;);\\nconsole.log(str);\\n\\n//使用正则\\nstr.replace(/zhufeng/g,&quot;珠峰&quot;);\\nconsole.log(&quot;珠峰&quot;)</code></pre> <h4 id=2，一些不使用正则的情况>2，一些不使用正则的情况</h4> <pre><code class=language-javascript>let str=&quot;zhufeng@2019|zhufeng@2020&quot;;\\n\\n//需求2：把“zhufeng”替换成“zhufengpeixun”；\\n\\n//不使用正则\\nstr=str.replace(&quot;zhufeng&quot;,&quot;zhufengpeixun&quot;).replace(&quot;zhufeng&quot;,&quot;zhufengpeixun&quot;);\\nconsole.log(str);\\n\\nstr=&quot;zhufeng@2019|zhufeng@2020&quot;;\\n//使用正则\\nstr=str.replace(/zhufeng/g,&quot;zhufengpeixun&quot;)\\nconsole.log(str);\\n</code></pre> <h4 id=3，案例：把时间字符串进行处理>3，案例：把时间字符串进行处理</h4> <pre><code class=language-javascript>let time=&quot;2019-08-13&quot;\\n//=&gt;变为&quot;2019年08月13日&quot;\\n\\nlet reg=/^(\\\\d{4})-(\\\\d{1,2})-(\\\\d{1,2})$/;\\n\\n//方法1\\ntime=time.replace(reg,&quot;$1年$2月$3日&quot;)\\nconsole.log(time);\\n\\n//方法2\\ntime=time.replace(reg,(...arg)=&gt;{\\n    //这里的$1-2-3是我们自己定义的变量\\n    let [,$1,$2,$3]=arg;\\n    $2.length&lt;2?&quot;0&quot;+$2:null;\\n    $3.length&lt;0?&quot;0&quot;+$3:null;\\n    return $1+&quot;年&quot;+$2+&#39;月&#39;+$3+&quot;日&quot;\\n});\\n//1,首先拿reg和time进行匹配捕获，能匹配到几次就会把传递的函数执行几次\\n//2,不仅把方法执行，而且replace方法还给方法传递了实参信息（和exec捕获内容一致的信息，大正则匹配的内容，小分组匹配的信息）\\n//3,函数中我们返回的是什么，就把当前匹配的内容替换成啥</code></pre> <h4 id=4，案例：单词首字母大写>4，案例：单词首字母大写</h4> <pre><code class=language-javascript>let str=&quot;good good study , day day up&quot;;\\n\\nlet reg=/\\\\b([a-zA-Z])[a-zA-Z]*\\\\b/g\\n//=&gt;每一次arg：[&quot;good&quot;,&quot;g&quot;],[&quot;good&quot;,&quot;g&quot;],[&quot;study&quot;,&quot;s&quot;]\\nstr=str.replace(reg,(...arg)=&gt;{\\n    console.log(arg);\\n    let [content,$1]=arg;\\n    $1=$1.toUpperCase();\\n    content=content.substring(1);\\n    return $1+content;\\n});\\nconsole.log(str);//=&gt;Good Good Study , Day Day Up</code></pre> <h4 id=5，验证一个字符串中，哪个字母出现次数最多，多少次>5，验证一个字符串中，哪个字母出现次数最多，多少次</h4> <ul> <li>不使用正则</li> </ul> <pre><code class=language-javascript>let str=&quot;zhufengpeixunzhoulaoshihaha&quot;;\\n\\nlet obj={};\\nlet index=0;\\nlet resultChar=&quot;&quot;;\\n[].forEach.call(str,char=&gt;{\\n\\n    //方法1\\n    //if(obj.hasOwnProperty(char)) obj[char]++;\\n    //else obj[char]=1;\\n\\n    //方法2\\n    if(typeof obj[char] !==&quot;undefined&quot;){\\n        obj[char] ++;\\n        if(obj[char] &gt; index){\\n            index=obj[char]\\n            resultChar = char\\n        }\\n        return;\\n    }\\n    obj[char]=1;\\n});\\nconsole.log(obj);\\nconsole.log(&#39;出现最多的字母&#39;,resultChar);\\nconsole.log(`${resultChar}出现次数最多`);</code></pre> <ul> <li>使用正则(我自己的方法)</li> </ul> <pre><code class=language-javascript>let str=&quot;zhufengpeixunzhoulaoshihaha&quot;;\\n\\nlet reg=/[a-zA-Z]{1}/g\\nlet obj={};\\nlet biggest=&quot;&quot;;\\nlet max=1;\\nstr=str.replace(reg,(...arg)=&gt;{\\n    console.log(arg);\\n    let [$1] =arg;\\n    if(typeof obj[$1]!==&quot;undefined&quot;) {\\n        obj[$1]++;\\n        if(obj[$1]&gt;max){\\n            max=obj[$1];\\n            biggest=$1;\\n        }\\n    }\\n    else obj[$1] = 1\\n    return $1;\\n});\\nconsole.log(obj);\\nconsole.log(biggest);</code></pre> <ul> <li>数组sort方法</li> </ul> <pre><code class=language-javascript>let str=&quot;zhufengpeixunzhoulaoshihaha&quot;;\\n\\nstr=str.split(&#39;&#39;).sort((a,b)=&gt;a.localeCompare(b)).join(&#39;&#39;);\\nconsole.log(str);\\n\\nlet reg=/([a-zA-Z])\\\\1+/g;\\nlet ary=str.match(reg);\\nary.sort((a,b)=&gt;b.length-a.length);\\nconsole.log(ary);//=&gt;[&quot;hhhhh&quot;, &quot;aaa&quot;, &quot;uuu&quot;, &quot;ee&quot;, &quot;ii&quot;, &quot;nn&quot;, &quot;oo&quot;, &quot;zz&quot;]\\nconsole.log(&quot;出现次数最多的字母&quot;,ary[0].slice(0,1),ary[0].length)</code></pre> <ul> <li>多个正则</li> </ul> <pre><code class=language-javascript>let str=&quot;zhufengpeixunzhoulaoshihaha&quot;;\\nstr=str.split(&#39;&#39;).sort((a,b)=&gt;a.localeCompare(b)).join(&#39;&#39;);\\nlet time=0;\\nlet reg=new RegExp(&quot;([a-zA-Z])\\\\\\\\1{&quot;+time+&#39;}&#39;,&#39;g&#39;);\\nlet res=str.match(reg);\\nlet final=[];\\nwhile(res&amp;&amp;res.length&gt;0){\\n        console.log(res);\\n    final=res;\\n    time++;\\n    reg=new RegExp(&quot;([a-zA-Z])\\\\\\\\1{&quot;+time+&#39;}&#39;,&#39;g&#39;);\\n    res=str.match(reg);\\n}\\nconsole.log(`出现次数最多的字母${final[0].slice(0,1)},出现次数为${final[0].length}`);</code></pre> <ul> <li>删减字符串</li> </ul> <pre><code class=language-javascript>let str=&quot;zhufengpeixunzhoulaoshihahazzzffff&quot;;\\nlet result=[];\\nlet max=0;\\nlet letter=&quot;&quot;;\\nlet reg;\\nwhile(str!=&quot;&quot; &amp;&amp; max&lt;str.length){\\n    let oldlength =str.length;\\n    letter=str.slice(0,1);\\n    console.log(letter);\\n    reg=new RegExp(letter,&quot;g&quot;);\\n    str=str.replace(reg,&quot;&quot;);//将重复字母删除\\n    let newlength=str.length;\\n    let lettercount=oldlength-newlength;//删除字符的出现次数\\n    if(lettercount &gt; max){\\n        result=[];\\n        max=lettercount;\\n    }\\n    if(lettercount === max){\\n        result.push(letter);\\n    }\\n}\\nconsole.log(`出现次数最多的字母${result},出现次数为${max}`);</code></pre> \";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h3 id=正则的捕获>正则的捕获</h3> <p>1，实现正则的捕获方法</p> <pre><code class=language-javascript>    RegExp.prototype.\\n​    exec\\n​    test\\n\\n​    String.prototype.\\n​    replace,\\n​    match\\n​    splice</code></pre> <p>2，实现正则捕获的前提是当前正则和字符串匹配</p> <p>如果不匹配，捕获的结果是null。</p> <p>基于exec实现的正则：</p> <p>1）捕获到的结果是null或者一个数组</p> <ul> <li>第一项：本次捕获的内容</li> <li>其余项：对应小分组本次单独捕获的内容</li> <li>index：当前捕获内容在字符串中的起始索引</li> <li>input：原始字符串</li> </ul> <p>2）每执行1次exec只能捕获一个符合规则的</p> <p>3，正则捕获的懒惰性</p> <p>默认只捕获第一个。</p> <p>原因：默认情况下lastIndex的值不会发生改变。</p> <p>4，解决方案：</p> <pre><code class=language-javascript>let str=&#39;zhufeng2019peixun2020banji2021&#39;\\nlet reg=/\\\\d+/g                //全局修饰符g\\nreg.exec(str);                \\nconsole.log(reg.lastIndex); //11\\nreg.exec(str);    \\nconsole.log(reg.lastIndex); //21\\nreg.exec(str);\\nconsole.log(reg.lastIndex);    //30\\nreg.exec(str);\\nconsole.log(reg.lastIndex);    //0 当lastIndex为0时，捕获结束</code></pre> <p>5，reg.test也会改变lastIndex的值</p> <p>6，编写一个方法execAll</p> <p>需求：执行一次可以把所有匹配的结果捕获到，前提时正则一定要设置全局修饰符g</p> <pre><code class=language-javascript>~function(){\\n    function execAll(str=&quot;&quot;){\\n        //先判断正则是否包含全局捕获g\\n        //如果不设置g，则会陷入死循环\\n        if(!this.global){\\n            return this.exec(str);\\n        }\\n\\n        //str:要匹配的字符串\\n        //this:RegExp的实例，当前操作的正则\\n        let res=this.exec(str);    //每一次捕获的内容\\n        let ary=[]        //存储捕获的全部内容\\n        while(res){\\n            //只要捕获的内容不为null，则继续捕获\\n            ary.push(res[0]);//把每次捕获的内容存放到ary中\\n            res=this.exec(str);\\n        }\\n        return ary;\\n    }\\n    RegExp.prototype.execAll=execAll;\\n}\\n\\nlet reg=/\\\\d+/g\\nreg.execAll(str);\\n\\n等同于\\nstr.match(reg);</code></pre> \";\n// Exports\nmodule.exports = code;","var map = {\n\t\"./1-正则简单介绍.md\": \"30f5\",\n\t\"./2-常用的正则表达式.md\": \"3e07\",\n\t\"./3-Replace方法与正则.md\": \"a11d\",\n\t\"./4-正则的捕获.md\": \"a78f\",\n\t\"./5-分组捕获和分组引用.md\": \"1367\",\n\t\"./6-正则捕获的贪婪性.md\": \"d264\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"c25b\";","// Module\nvar code = \"<h2 id=正则捕获的贪婪性>正则捕获的贪婪性</h2> <p>1，什么是贪婪性</p> <pre><code class=language-javascript>let str=&quot;zhufeng2019@2020peixun&quot;\\nlet reg=/\\\\d+/g;\\n\\n//正则捕获的贪婪性：默认情况下，正则捕获的时候，是按照当前正则所匹配的最长结果来获取的\\n\\nstr.match(reg) //=&gt;[&quot;2019&quot;,&quot;2020&quot;]\\n\\n//如何取消正则捕获的贪婪性\\n//在量词元字符后面设置?\\nlet reg=/\\\\d+?/g\\n\\nconsole.log(str.match(reg)) //[&quot;2&quot;,&quot;0&quot;,&quot;1&quot;,&quot;9&quot;,&quot;2&quot;,&quot;0&quot;,&quot;2&quot;,&quot;0&quot;]</code></pre> <p>2，？在正则中的作用</p> <ul> <li>问号左边是非量词元字符：本身代表量词元字符，出现零到1次</li> <li>问号左边是量词元字符，取消贪婪性</li> <li>（？：）只匹配不捕获</li> <li>（？=) 正向预查</li> <li>（？！）负向预查</li> </ul> \";\n// Exports\nmodule.exports = code;","var map = {\n\t\"./Vue响应式源码.md\": \"f5a4\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"ea64\";","const ArticleData=[\r\n\r\n  {\r\n    type:\"RegExp\",\r\n    title:\"正则表达式\",\r\n    articleNames:require.context('markdown/AboutRegExp',false,/\\.md$/).keys(),\r\n    articleContent:require.context('markdown/AboutRegExp',false,/\\.md$/)\r\n  },\r\n  {\r\n    type:\"Webpack\",\r\n    title:\"Webpack\",\r\n    articleNames:require.context('markdown/AboutWebpack',false,/\\.md$/).keys(),\r\n    articleContent:require.context('markdown/AboutWebpack',false,/\\.md$/)\r\n  },\r\n  {\r\n    type:\"Vue\",\r\n    title:\"Vue\",\r\n    articleNames:require.context('markdown/AboutVue',false,/\\.md$/).keys(),\r\n    articleContent:require.context('markdown/AboutVue',false,/\\.md$/)\r\n  },\r\n  {\r\n    type:\"React\",\r\n    title:\"React\",\r\n    articleNames:require.context('markdown/AboutReact',false,/\\.md$/).keys(),\r\n    articleContent:require.context('markdown/AboutReact',false,/\\.md$/)\r\n  },\r\n  {\r\n    type:\"Laya\",\r\n    title:\"Laya\",\r\n    articleNames:require.context('markdown/AboutLaya',false,/\\.md$/).keys(),\r\n    articleContent:require.context('markdown/AboutLaya',false,/\\.md$/)\r\n  },\r\n  {\r\n    type:\"DataStructure\",\r\n    title:\"数据结构\",\r\n    articleNames:require.context('markdown/AboutDataStructure',false,/\\.md$/).keys(),\r\n    articleContent:require.context('markdown/AboutDataStructure',false,/\\.md$/)\r\n  },\r\n  {\r\n    type:\"JS\",\r\n    title:\"JS基础\",\r\n    articleNames:require.context('markdown/AboutJS',false,/\\.md$/).keys(),\r\n    articleContent:require.context('markdown/AboutJS',false,/\\.md$/)\r\n  },\r\n  {\r\n    type:\"Algorithm\",\r\n    title:\"算法\",\r\n    articleNames:require.context('markdown/AboutAlgorithm',false,/\\.md$/).keys(),\r\n    articleContent:require.context('markdown/AboutAlgorithm',false,/\\.md$/)\r\n  }\r\n]\r\n\r\nexport default ArticleData;","// Module\nvar code = \"<h2 id=webpack><strong>Webpack</strong></h2> <h3 id=1，什么是webpack>1，什么是webpack</h3> <p>​ 现代的javascript应用的静态<strong>模块打包</strong>工具。</p> <p>​ </p> <h3 id=2，webpack作用>2，webpack作用</h3> <p>识别某些写法，将其转化为浏览器能识别的写法。</p> <p>会帮助我们处理模块之间的依赖关系。</p> <p>将项目打包。</p> <h3 id=3，与gulp对比>3，与gulp对比</h3> <p>gulp更强调的是<strong>前端流程的自动化</strong>，模块化不是核心。</p> <p>webpack更强调<strong>模块化开发</strong>管理。文件压缩，预处理等功能，是他附带的功能。</p> <h3 id=4，webpack安装>4，webpack安装</h3> <p>本身依赖node.js环境。</p> <p>webpack ./src/main.js -o ./src/bundle.js --mode -development</p> <h3 id=5，webpack配置>5，webpack配置</h3> <p>开发时依赖</p> <p>运行时依赖</p> <h3 id=6，loader>6，loader</h3> <p>css文件处理。还需要style.loader。</p> <p>less文件处理。还需要依赖less</p> <p>图片处理。还需要fileloader</p> <p>vueloader处理。</p> <p>babelloader。js转es5处理。</p> <h3 id=7，plugins>7，plugins</h3> <p>1），添加版权声明的横幅plugin new webpack.bannerplugin（&#39;xxxxxxxx&#39;）；</p> <p>2），打包index.html的HtmlWebpackPlugin</p> <p>3），压缩混淆代码插件uglifyjs.。</p> <p>4），webpack-dev-server 当我们保存src文件夹里的代码时，会自动编译到内存中。</p> <p>5），VueLoaderPlugin</p> <h3 id=8搭建本地服务器>8,搭建本地服务器</h3> <p>web-dev-server。</p> <h3 id=9webpack配置文件的分离>9,webpack配置文件的分离</h3> <p>1，依赖webpack-merge</p> <p>2，需要为不同环境配置不同的配置文件base.config.js/dev.config.js/prod.config.js</p> <h3 id=10webpack的目录结构>10,webpack的目录结构</h3> <h3 id=entry：>entry：</h3> <p>webpack启动的入口</p> <h3 id=output：>output：</h3> <p>导出到哪个文件夹，并如何命名导出的文件</p> <h3 id=loaders：>loaders：</h3> <p>webpack默认只识别javascript和json，loaders允许webpack识别并转化这些类型的文件并且将他们转化为可识别的模块。将这些文件添加到依赖的graph中。</p> <p>通过构建规则的方式，将某一种文件与相应的解析器绑定起来。</p> <pre><code class=language-javascript>modeule.exports={\\n    rules:[\\n        {test:/\\\\.txt$/,use:&#39;raw-loader&#39;}\\n    ]\\n}</code></pre> <h3 id=plugins：>plugins：</h3> <p>为项目提供其他的辅助功能。</p> <h3 id=mode>mode:</h3> <p>可以将模式设置为development，production或者none。</p> \";\n// Exports\nmodule.exports = code;","// Module\nvar code = \"<h1 id=vue响应式的实现>Vue响应式的实现</h1> <pre><code class=language-javascript>class FanVue {\\n  constructor(options) {\\n    //保存数据\\n    this.$options = options;\\n    this.$data = this.$options.data;\\n    this.$el = this.$options.el;\\n    //将data添加到响应式系统\\n    new Observer(this.$data);\\n    //代理this.$data中的数据\\n    Object.keys(this.$data).forEach(key =&gt; {\\n      this._proxy(key);\\n    });\\n    //处理el下面的所有节点\\n    new Compiler(this.$el, this);\\n  }\\n\\n  //设置代理。这样可以直接使用this.message===xxx\\n  //来代替this.$data.message\\n  _proxy(key) {\\n    Object.defineProperty(this, key, {\\n      configurable: true,\\n      enumerable: true,\\n      set(newValue) {\\n        this.$data[key] = newValue;\\n      },\\n      get() {\\n        return this.$data[key];\\n      }\\n    })\\n  }\\n}\\n\\n//添加观察者\\n//观察者的主要功能是重新定义每个data的get和set方法\\n//使data里数据的获取和修改能被监听\\nclass Observer {\\n  constructor(data) {\\n    this.data = data;\\n    Object.keys(data).forEach(key =&gt; {\\n      this.defineReactive(data, key, data[key]);\\n    });\\n  }\\n  //定义响应式\\n  defineReactive(data, key, value) {\\n    //每添加一个响应式的对象，则为其创建一个Dep对象\\n    let dep = new Dep();\\n    Object.defineProperty(data, key, {\\n      enumerable: true,//该属性的描述符才能够改变\\n      configurable: false,//该属性会出现在枚举属性中\\n      get() {\\n        //当通过compiler初次编译dom节点时，可以获取到所有的依赖\\n        //将这些依赖跟对应的属性绑定起来\\n        //添加到一个Dep的subscribers数组里面。\\n        console.log(Dep.target);\\n        //每一个Dep的target指向的一个watcher对象。\\n        if (Dep.target) { //只有初次Watcher添加依赖的时候，才会添加订阅者，之后不会再添加，为null\\n          dep.addSub(Dep.target)\\n        }\\n        return value;\\n      },\\n      set(newVal) {\\n        if (newVal === value) {\\n          return;\\n        }\\n        value = newVal;\\n        dep.notify();\\n      }\\n    })\\n  }\\n}\\n\\nclass Watcher {\\n  constructor(node, name, vm) {\\n    this.node = node;\\n    this.name = name;\\n    this.vm = vm;\\n    Dep.target = this;\\n    this.update();\\n    Dep.target = null;\\n  }\\n\\n  //通知变化\\n  update() {\\n    this.node.nodeValue = this.vm[this.name]\\n  }\\n}\\n\\nclass Dep {\\n  constructor() {\\n    this.subscribers = [];\\n  }\\n  addSub(sub) {\\n    this.subscribers.push(sub);\\n  }\\n  notify() {\\n    this.subscribers.forEach(sub =&gt; {\\n      sub.update();\\n    })\\n  }\\n}\\n\\n//将原本的页面进行重新编译\\nconst regExp = /\\\\{\\\\{(.*)\\\\}\\\\}/ //识别双大括号的正则表达式\\nclass Compiler {\\n  constructor(el, vm) {\\n    this.el = document.querySelector(el);\\n    console.log(this.el);\\n    this.vm = vm;\\n    this.frag = this._createFragment();\\n    this.el.appendChild(this.frag);\\n  }\\n\\n  _createFragment() {\\n    const frag = document.createDocumentFragment();\\n    let child;\\n    while (child = this.el.firstChild) {\\n      this._compile(child);\\n      frag.appendChild(child);\\n    }\\n    return frag;\\n  }\\n\\n  _compile(node) {\\n    console.log(node.nodeType);\\n    if (node.nodeType == 1) {\\n      const attrs = node.attributes;\\n      if (attrs.hasOwnProperty(&#39;v-model&#39;)) {\\n        const name = attrs[&#39;v-model&#39;].nodeValue;\\n        node.addEventListener(&#39;input&#39;, e =&gt; {\\n          this.vm[name] = e.target.value;\\n        })\\n      }\\n      for (let i = 0; i &lt; node.childNodes.length; i++) {\\n        this._compile(node.childNodes[i]);\\n      }\\n    }\\n\\n    if (node.nodeType === 3) {\\n      if (regExp.test(node.nodeValue)) {\\n        const name = RegExp.$1.trim();\\n        new Watcher(node, name, this.vm);\\n      }\\n    }\\n  }\\n}</code></pre> \";\n// Exports\nmodule.exports = code;"],"sourceRoot":""}