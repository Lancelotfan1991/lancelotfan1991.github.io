(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{390:function(t,e,o){"use strict";o.r(e);var r=o(42),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"reacthooks系列-1-入门"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#reacthooks系列-1-入门"}},[t._v("#")]),t._v(" ReactHooks系列(1)-入门")]),t._v(" "),o("h2",{attrs:{id:"_1，为什么要有hooks"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1，为什么要有hooks"}},[t._v("#")]),t._v(" 1，为什么要有hooks")]),t._v(" "),o("blockquote",[o("p",[o("em",[t._v("Hook")]),t._v(" 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。")])]),t._v(" "),o("h2",{attrs:{id:"_2，hooks的优势："}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2，hooks的优势："}},[t._v("#")]),t._v(" 2，hooks的优势：")]),t._v(" "),o("blockquote",[o("p",[o("strong",[t._v("Hook 使你在无需修改组件结构的情况下复用状态逻辑。")]),t._v("  (减少了 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成的“嵌套地狱”。 )")]),t._v(" "),o("p",[o("strong",[t._v("Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）")]),t._v("，而并非强制按照生命周期划分。")]),t._v(" "),o("p",[o("strong",[t._v("Hook 使你在非 class 的情况下可以使用更多的 React 特性。")]),t._v(" （拥抱函数）")])]),t._v(" "),o("h2",{attrs:{id:"_3，一些主要的hook以及他们的使用场景："}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3，一些主要的hook以及他们的使用场景："}},[t._v("#")]),t._v(" 3，一些主要的Hook以及他们的使用场景：")]),t._v(" "),o("table",[o("thead",[o("tr",[o("th",[t._v("hook")]),t._v(" "),o("th",{staticStyle:{"text-align":"center"}},[t._v("使用场景")])])]),t._v(" "),o("tbody",[o("tr",[o("td",[o("RouterLink",{attrs:{to:"/markdowns/AboutReact/ReactHooks/useState的使用.html"}},[t._v("useState")])],1),t._v(" "),o("td",{staticStyle:{"text-align":"center"}},[t._v("一个基础的hook，允许你在函数式组件中使用state")])]),t._v(" "),o("tr",[o("td",[o("RouterLink",{attrs:{to:"/markdowns/AboutReact/ReactHooks/useEffect的使用.html"}},[t._v("useEffect")])],1),t._v(" "),o("td",{staticStyle:{"text-align":"center"}},[t._v("使函数式组件可以拥有类似生命周期，订阅取消订阅事件的能力，允许我们将订阅/取消订阅，网络请求等事件拆分开，减少耦合。")])]),t._v(" "),o("tr",[o("td",[o("RouterLink",{attrs:{to:"/markdowns/AboutReact/ReactHooks/useContext的使用.html"}},[t._v("useContext")])],1),t._v(" "),o("td",{staticStyle:{"text-align":"center"}},[t._v("可以允许用更简便的方式使用context")])]),t._v(" "),o("tr",[o("td",[t._v("useReducer")]),t._v(" "),o("td",{staticStyle:{"text-align":"center"}},[t._v("useState的替代方案，处理复杂的state逻辑")])]),t._v(" "),o("tr",[o("td",[t._v("useCallback")]),t._v(" "),o("td",{staticStyle:{"text-align":"center"}},[t._v("返回一个memoized回调函数，避免重复调用某个函数")])]),t._v(" "),o("tr",[o("td",[t._v("useMemo")]),t._v(" "),o("td",{staticStyle:{"text-align":"center"}},[t._v("返回一个memoized值，避免重复计算")])]),t._v(" "),o("tr",[o("td",[t._v("useRef")]),t._v(" "),o("td",{staticStyle:{"text-align":"center"}},[t._v("返回一个可变的 ref 对象，其 "),o("code",[t._v(".current")]),t._v(" 属性被初始化为传入的参数（"),o("code",[t._v("initialValue")]),t._v("）。返回的 ref 对象在组件的整个生命周期内保持不变。")])]),t._v(" "),o("tr",[o("td",[t._v("useImperativeHandle")]),t._v(" "),o("td",{staticStyle:{"text-align":"center"}},[t._v("使用 "),o("code",[t._v("ref")]),t._v(" 时自定义暴露给父组件的实例值，应当与fowardRef一起使用")])]),t._v(" "),o("tr",[o("td",[t._v("useLayoutEffect")]),t._v(" "),o("td",{staticStyle:{"text-align":"center"}},[t._v("其函数签名与 "),o("code",[t._v("useEffect")]),t._v(" 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染")])])])]),t._v(" "),o("h2",{attrs:{id:"_4，什么是memoized"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4，什么是memoized"}},[t._v("#")]),t._v(" 4，什么是memoized")]),t._v(" "),o("p",[t._v("摘自wiki：")]),t._v(" "),o("blockquote",[o("p",[t._v("In "),o("a",{attrs:{href:"https://en.wikipedia.org/wiki/Computing",target:"_blank",rel:"noopener noreferrer"}},[t._v("computing"),o("OutboundLink")],1),t._v(", "),o("strong",[t._v("memoization")]),t._v(" or "),o("strong",[t._v("memoisation")]),t._v(" is an "),o("a",{attrs:{href:"https://en.wikipedia.org/wiki/Optimization_(computer_science)",target:"_blank",rel:"noopener noreferrer"}},[t._v("optimization"),o("OutboundLink")],1),t._v(" technique used primarily to speed up "),o("a",{attrs:{href:"https://en.wikipedia.org/wiki/Computer_programs",target:"_blank",rel:"noopener noreferrer"}},[t._v("computer programs"),o("OutboundLink")],1),t._v(" by storing the results of expensive "),o("a",{attrs:{href:"https://en.wikipedia.org/wiki/Subroutine",target:"_blank",rel:"noopener noreferrer"}},[t._v("function calls"),o("OutboundLink")],1),t._v(" and returning the cached result when the same inputs occur again.")])]),t._v(" "),o("p",[t._v("翻译：")]),t._v(" "),o("blockquote",[o("p",[t._v("memoization是一种优化技巧，主要用法：存储那些性能开销比较大的方法的运行结果，当输入的值相同的时候，会返回一个已经缓存的值，而非重新计算。从而提高计算机程序的速度。")])]),t._v(" "),o("p",[t._v("摘自wiki")]),t._v(" "),o("blockquote",[o("p",[t._v("Memoization is a way to lower a function's "),o("em",[t._v("time")]),t._v(" cost in exchange for "),o("em",[t._v("space")]),t._v(" cost;")])]),t._v(" "),o("p",[t._v("翻译：")]),t._v(" "),o("blockquote",[o("p",[t._v("Memoization 通过更大的空间成本（由于结果被缓存，所以增加了内存占用），从而降低了函数的时间成本（提高了程序的运行速度）。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);