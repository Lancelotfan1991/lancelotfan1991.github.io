(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{357:function(t,a,r){"use strict";r.r(a);var s=r(42),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),r("h2",{attrs:{id:"第一部分：几个核心概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第一部分：几个核心概念"}},[t._v("#")]),t._v(" 第一部分：几个核心概念")]),t._v(" "),r("h3",{attrs:{id:"贪心算法："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法："}},[t._v("#")]),t._v(" 贪心算法：")]),t._v(" "),r("p",[t._v("Greedy Algorithm，从问题的某个初始解开始逐步推导，直到求到最优解（但是贪心算法得到的解并不一定是最优解）。")]),t._v(" "),r("h3",{attrs:{id:"动态规划："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态规划："}},[t._v("#")]),t._v(" 动态规划：")]),t._v(" "),r("p",[t._v("Dynamic Programming，将复杂的问题分解为子问题，然后寻找子问题之间的关联，从而得到最优解。")]),t._v(" "),r("h3",{attrs:{id:"空间复杂度："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#空间复杂度："}},[t._v("#")]),t._v(" 空间复杂度：")]),t._v(" "),r("p",[t._v("解决一个问题，所需占用的内存空间和元素数量n之间的关系即为空间复杂度。")]),t._v(" "),r("h3",{attrs:{id:"时间复杂度："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度："}},[t._v("#")]),t._v(" 时间复杂度：")]),t._v(" "),r("p",[t._v("所需花费的时间（或者说运算次数）和元素数量之间的关系，即为时间复杂度。")]),t._v(" "),r("h3",{attrs:{id:"状态转移方程："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#状态转移方程："}},[t._v("#")]),t._v(" 状态转移方程：")]),t._v(" "),r("blockquote",[r("p",[t._v("动态规划中本阶段的状态往往是上一阶段状态和上一阶段决策的结果。若给定了第K阶段的状态Sk以及决策uk(Sk),则第K+1阶段的状态Sk+1也就完全确定。也就是说Sk+1与Sk,uk之间存在一种明确的数量对应关系,记为Tk(Sk,uk),即有Sk+1= Tk(Sk,uk)。 这种用函数表示前后阶段关系的方程,称为状态转移方程。在上例中状态转移方程为 Sk+1= uk(Sk)")])]),t._v(" "),r("h2",{attrs:{id:"第二部分：算法中常见要解决的问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二部分：算法中常见要解决的问题"}},[t._v("#")]),t._v(" 第二部分：算法中常见要解决的问题")]),t._v(" "),r("p",[t._v("1，排序算法(快速排序，冒泡排序)")]),t._v(" "),r("p",[t._v("2，搜索(广度优先搜索，深度优先搜索)")]),t._v(" "),r("h2",{attrs:{id:"第二部分：算法题目录"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二部分：算法题目录"}},[t._v("#")]),t._v(" 第二部分：算法题目录")]),t._v(" "),r("h3",{attrs:{id:"_1-剑指offer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-剑指offer"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"./%E5%89%91%E6%8C%87Offer"}},[t._v("1-剑指Offer")])]),t._v(" "),r("h3",{attrs:{id:"_2-leetcode"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-leetcode"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"./LeetCode"}},[t._v("2-LeetCode")])]),t._v(" "),r("h3",{attrs:{id:"_3-其他途径接触到的算法题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-其他途径接触到的算法题"}},[t._v("#")]),t._v(" [3-其他途径接触到的算法题]")])])}),[],!1,null,null,null);a.default=e.exports}}]);