(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{424:function(e,_,n){"use strict";n.r(_);var a=n(42),r=Object(a.a)({},(function(){var e=this,_=e.$createElement,n=e._self._c||_;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"webpack处理模块化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack处理模块化"}},[e._v("#")]),e._v(" Webpack处理模块化")]),e._v(" "),n("p",[e._v("js的模块化一般意义上指的是两种：")]),e._v(" "),n("p",[e._v("一种是ES6推出的模块化，这种模块化，使用的是import和export字段来实现导入和导出。")]),e._v(" "),n("p",[e._v("另一种是commonjs推出的模块化，这种模块化，使用的是module.exports来进行导出，使用require来引入。")]),e._v(" "),n("p",[e._v("但是，尽管我们可以在编写代码时，使用这两种方式，浏览器事实上对于js模块化的支持是不完善的。")]),e._v(" "),n("p",[e._v("为了让浏览器能够正确识别模块化，我们就需要借助Webpack。")]),e._v(" "),n("h3",{attrs:{id:"准备工作（如何配置）："}},[n("a",{staticClass:"header-anchor",attrs:{href:"#准备工作（如何配置）："}},[e._v("#")]),e._v(" 准备工作（如何配置）：")]),e._v(" "),n("p",[e._v("为了能看到webpack的打包后的代码能够分析，需要进行正确的设置：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const path = require('path');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    mode: 'development',\t// 核心1\n    entry: './src/common_index.js',\n    devtool: 'source-map',\t// 核心2\n    output: {\n        filename: 'js/bundle.js',\n        path: path.resolve(__dirname, './build')\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            title: 'fantasy webpack'\n        }),\n        new CleanWebpackPlugin()\n    ]\n}\n")])])]),n("h3",{attrs:{id:"_1，commonjs实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1，commonjs实现原理"}},[e._v("#")]),e._v(" 1，CommonJS实现原理")]),e._v(" "),n("p",[e._v("首先：我们需要写一个使用Commonjs实现模块化的js文件。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function dateFormat(date){\n    return date;\n}\n\nfunction priceFormat(price){\n    return price;\n}\n\nmodule.exports = {\n    dateFormat,\n    priceFormat\n}\n")])])]),n("p",[e._v("接着：我们在index.js中调用该模块。并输出。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const { dateFormat, priceFormat } = require('./js/format.js');\n\nconsole.log(dateFormat('aaa'));\nconsole.log(priceFormat('bbb'));\n")])])]),n("p",[e._v("第三步：运行webpack打包：")]),e._v(" "),n("p",[e._v("我们可以得到编译后的bundle.js。")]),e._v(" "),n("p",[e._v("第四步：删去bundle.js的注释后，我们可以得到最终webpack帮助我们编译的代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("var __webpack_modules__ = {\n    // 模块的路径作为key\n    // 模块的函数作为value\n    \"./src/js/format.js\":\n        ((module) => {\n            function dateFormat(date) {\n                return date;\n            }\n            function priceFormat(price) {\n                return price;\n            }\n            module.exports = {\n                dateFormat,\n                priceFormat\n            }\n        })\n};\n\nvar __webpack_module_cache__ = {};\n\nfunction __webpack_require__(moduleId) {\n    if (__webpack_module_cache__[moduleId]) {\n        return __webpack_module_cache__[moduleId].exports;\n    }\n    var module = __webpack_module_cache__[moduleId] = {\n        exports: {}\n    };\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    return module.exports;\n}\n\n// 具体执行的代码\n(() => {\n    const { dateFormat, priceFormat } = __webpack_require__(\"./src/js/format.js\");\n\n    console.log(dateFormat('aaa'));\n    console.log(priceFormat('bbb'));\n})();\n\n//# sourceMappingURL=bundle.js.map\n")])])]),n("p",[e._v("这段代码的核心是：")]),e._v(" "),n("p",[e._v("（1）"),n("code",[e._v("__webpack_modules__")]),e._v(":存储了源代码中的所有模块，以路径为key。对象的内容是模块的映射。")]),e._v(" "),n("p",[e._v("（2）"),n("code",[e._v("__webpack_require__")]),e._v("方法：这个函数会从modules中去加载对应的模块。webpack将我们编写的代码中的require，替换为该方法。当我们调用这个方法时，便会从modules中调用对应模块的映射代码，并同时传入module，module.exports以及"),n("code",[e._v("__webpack_require__")]),e._v("函数本身。最终的返回值，便是原函数的module.exports。")]),e._v(" "),n("p",[e._v("（3）"),n("code",[e._v("__webpack_module_cache__")]),e._v("对象：用于缓存模块。这样第二次获取模块时，可以直接从缓存中获取指定的对象，而不会再次执行模块代码。比如第一次引用模块时，经过己算导出的是：{ a, b } 那么，第二次引用该模块时，便会直接得到a和b。")]),e._v(" "),n("h3",{attrs:{id:"_2，es6-module实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2，es6-module实现原理"}},[e._v("#")]),e._v(" 2，ES6 module实现原理")]),e._v(" "),n("p",[e._v("Webpack在处理es6的模块化代码时，与上面有所不同。区别在于：commonjs使用module.exports来集中的导出对象，而es的module，则可以导出多个对象。webpack需要将这些对象统一集中起来，形成一个模块。")]),e._v(" "),n("p",[e._v("首先我们需要写一个用esmodule：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export const sum =function(a, b){\n    return a + b;\n}\n\nexport const mul =function(a, b){\n    return a * b;\n}\n")])])]),n("p",[e._v("然后在index.js中引用该模块：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import {sum, mul} from './js/math'\n\nconsole.log('sum', sum(10, 20));\nconsole.log('mul', mul(30, 40));\n")])])]),n("p",[e._v("运行npm run webpack：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('var __webpack_modules__ = ({\n    "./src/esmodule_index.js":\n        ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n            __webpack_require__.r(__webpack_exports__);\n            var _js_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("./src/js/math.js");\n\n\n            console.log(\'sum\', (0, _js_math__WEBPACK_IMPORTED_MODULE_0__.sum)(10, 20));\n            console.log(\'mul\', (0, _js_math__WEBPACK_IMPORTED_MODULE_0__.mul)(30, 40));\n        }),\n\n    "./src/js/math.js":\n        ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n            \n            // 调用了d函数，给exports设置了一个代理。\n            // exports对象本身没有对应的函数。当我们调用sum时，事实上是调用的是原模块中的sum。\n            __webpack_require__.r(__webpack_exports__);\n            __webpack_require__.d(__webpack_exports__, {\n                "sum": () => (sum),\n                "mul": () => (mul)\n            });\n            const sum = function (a, b) {\n                return a + b;\n            }\n            const mul = function (a, b) {\n                return a * b;\n            }\n        })\n});\n\nvar __webpack_module_cache__ = {};\n\nfunction __webpack_require__(moduleId) {\n    if (__webpack_module_cache__[moduleId]) {\n        return __webpack_module_cache__[moduleId].exports;\n    }\n    var module = __webpack_module_cache__[moduleId] = {\n        exports: {}\n    };\n\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n    return module.exports;\n}\n\n// 比较exports对象和definition对象的每一个key\n// exports对象中不存在，而在definition中存在的key，会被复制到exports中\n(() => {\n    __webpack_require__.d = (exports, definition) => {\n        for (var key in definition) {\n            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n                Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n            }\n        }\n    };\n})();\n\n// 判断一个obj是否拥有prop的属性\n(() => {\n    __webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n})();\n\n// 如果可以使用symbol那么，就使用symbol，给exports对象添加一个Symbol.toStringTag为module\n// 这样当我们对exports对象进行toString的时候，就可以得到[object Module]而不是[object object]\n// 同时，我们也给exports对象添加一个__esModule属性，值为true，\n// 这个r函数的作用，就是给一个对象添加module属性，告知这是一个模块对象。\n(() => {\n    __webpack_require__.r = (exports) => {\n        if (typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n            Object.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n        }\n        Object.defineProperty(exports, \'__esModule\', { value: true });\n    };\n})();\n\n__webpack_require__("./src/esmodule_index.js");\n\n//# sourceMappingURL=bundle.js.map\n')])])])])}),[],!1,null,null,null);_.default=r.exports}}]);